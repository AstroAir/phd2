<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>Алгоритмы гидирования</title>
  </head>
  <body>
    <h2>Алгоритмы гидирования<br>
    </h2>
    <a href="#Guiding_Theory">Теория гидирования</a><br>
    <a href="#Guide_Algorithm_Parameters">Параметры алгоритмов
      гидирования</a><br>
    <br>
    <h3><a name="Guiding_Theory"></a>Теория гидирования<br>
    </h3>
    Заданные по умолчанию параметры алгоритмов гидирования <span
      style="font-style: italic;">PHD2</span> должны хорошо работать для
    большинства пользователей.&nbsp; Пока вы не поймёте основ
    гидирования и не приобретёте некоторый опыт, лучше их не
    изменять.&nbsp; Однако, если возникла необходимость какие-нибудь из
    них поменять, или просто желание поэкспериментировать, это можно
    сделать в окне 'Настройки', вызываемом нажатием кнопки 'Мозг'.&nbsp;
    Для каждого из алгоритмов существует свой набор параметров,&nbsp;
    управляющий командами гидирования, которые нужно послать монтировке,
    чтобы вернуть сместившуюся звезду в её исходное положение. <br>
    <br>
    Подробнее эти параметры будут рассмотрены позже, а пока - немного
    теории гидирования. Оставив вне нашего рассмотрения устройства
    адаптивной оптики, о которых разговор отдельный, зададимся вопросом:
    чего именно мы хотим достичь?&nbsp;&nbsp; Задача в том, чтобы
    добиться от оборудования весом в десятки килограмм точности, при
    которой звёзды не будут выглядеть чёрточками или вытягиваться.&nbsp;
    Гидирование может исправить только медленные и повторяющиеся, но не
    быстрые и случайные ошибки слежения.&nbsp; Источниками медленных и
    повторяющихся ошибок могут быть: <br>
    <ul>
      <li>Несовершенство механической передачи прямого восхождения,
        порождающее в том числе и "периодическую ошибку"</li>
      <li>Небольшие ошибки ведения со звёздной скоростью<br>
      </li>
      <li>Атмосферная рефракция - звёзды у горизонта визуально
        перемещаются медленнее</li>
      <li>Небольшие механические отклонения - но <span
          style="font-weight: bold;">не </span>дифференциальное гнутие
        (провисание) трубы гида<br>
      </li>
      <li>Ошибка установки оси прямого восхождения на небесный полюс<br>
      </li>
    </ul>
    А что не вошло в этот список и не может быть исправлено обычным
    гидированием?&nbsp; К сожалению, список этот очень длинный.
    Основное: <br>
    <ul>
      <li>Состояние атмосферы ("турбулентность")</li>
      <li>Шероховатости механизмов, вибрация<br>
      </li>
      <li>Дифференциальное гнутие (провисание) трубы гида - смещение
        гидирующего телескопа относительно астрографа</li>
      <li>Порывы ветра, натянутый кабель, песок в механической передаче<br>
      </li>
      <li>И многое другое...</li>
    </ul>
    Общей особенностью алгоритмов гидирования является компенсация
    медленных и повторяющихся отклонений и игнорирование
    остальных.&nbsp; Это нелёгкая задача, поскольку свой вклад в
    отклонение звезды вносят разные источники.&nbsp; Монтировки
    несовершенны, и потому полученный результат может отличаться от
    ожидаемого.&nbsp; Основное требование любого алгоритма - избежать
    избыточной корректировки, когда монтировка будет перемещаться
    туда-сюда и стабильное гидирование будет невозможным.&nbsp;
    Aлгоритмы гидирования оперируют такими понятиями "инерция" и
    "сопротивление".&nbsp; Это означает связь текущей поправки с
    предыдущими и неохотное применение поправок, требующих изменений
    направления или амплитуды.&nbsp; Сопротивление изменению направления
    важно при гидировании по склонению, где основной проблемой является
    люфт.&nbsp; Надеемся, что вышенаписанное даст вам понимание основ
    гидирования и разъяснит использование различных параметров оного в <span
      style="font-style: italic;">PHD2</span>.<br>
    <h3><a name="Guide_Algorithm_Parameters"></a>Параметры алгоритмов
      гидирования<br>
    </h3>
    В <span style="font-style: italic;">PHD2</span> различные алгоритмы
    гидирования могут быть применены к обеим осям - прямого восхождения
    и склонения.&nbsp; Большинство из этих алгоритмов имеет параметр <span
      style="font-weight: bold;"><a name="minimum_move"></a>минимальное
      перемещение</span>.&nbsp; Он нужен, чтобы избежать слишком
    маленьких поправок, которые не будут иметь влияние на форму
    звезды.&nbsp; Поскольку задаётся он в пикселях, желательно знать
    размеры звёзд на изображениях.&nbsp; Если для конфигурирования
    системы используется помощник нового оборудования, он подберёт
    значения, которые, скорее всего, будут оптимальными для
    используемого увеличения.&nbsp;<span style="display: inline
      !important; float: none; background-color: transparent; color:
      rgb(0, 0, 0); font-family: Times New Roman; font-size: 16px;
      font-style: normal; font-variant: normal; font-weight: 400;
      letter-spacing: normal; orphans: 2; text-align: left;
      text-decoration: none; text-indent: 0px; text-transform: none;
      -webkit-text-stroke-width: 0px; white-space: normal; word-spacing:
      0px;"> Помощник гидирования тоже может, основываясь на измерении
      высокочастотных возмущений турбулентности, подобрать эти
      параметры.&nbsp; При излишне больших величинах подвижек и их
      постоянном инвертировании можно не поспевать корректировать
      турбулентность и тогда есть смысл увеличить значение минимального
      движения.&nbsp; Параметры минимального движения могут быть разными
      в разные ночи в зависимости от турбулентности.</span><br>
    <br>
    Алгоритм <a name="hysteresis"></a><span style="font-weight: bold;">гистерезис</span>
    помнит о предыдущих поправках и использует их при вычислении
    очередной. Параметр <span style="font-weight: bold;">гистерезис</span>,
    выраженный в процентах, определяет "вес" предыдущих поправок.&nbsp;
    Например, если гистерезис равен 10%, следующая поправка будет
    на&nbsp; 90% зависеть от перемещения звезды на текущем кадре и на
    10% от предыдущих поправок.&nbsp; Увеличение гистерезиса будет
    сглаживать поправки, которые могут оказаться недостаточными.&nbsp;
    Алгоритм гистерезиса также использует параметр <a
      name="aggressiveness"></a><span style="font-weight: bold;">агрессивность</span>,
    тоже выраженный в процентах;&nbsp; он используется, чтобы избежать
    избыточной корректировки. &nbsp; Для каждого кадра <span
      style="font-style: italic;">PHD2</span> подсчитывает расстояние и
    направление движения монтировки. Агрессивность задаёт коэффициент
    этой поправки. Например, если звезда сместилась на 0.5 пикселя, то
    при 100%, агрессивности поправка составит те же 0.5 пикселя, а при
    60% 0.3 пикселя. Если поправки всегда избыточны, агрессивность
    необходимо понемногу (например, по 10%) уменьшать. Если поправки не
    успевают за движением звезды, агрессивность нужно немного увеличить.
    &nbsp;<br>
    <br>
    Сущность алгоритма <a name="ResistSwitch"></a><span
      style="font-weight: bold;">минимизации переключений</span> ясна из
    его названия.&nbsp; Так же, как и алгоритм гистерезиса, он
    использует историю предыдущих поправок и любое изменение направления
    гидирования должно иметь убедительную причину.&nbsp; Он используется
    по умолчанию для гидирования по склонению, где смена направления
    нежелательна из-за люфта, в отличие от прямого восхождения, где
    смена направления движения ожидаема. <span style="display: inline
      !important; float: none; background-color: transparent; color:
      rgb(0, 0, 0); font-family: Times New Roman; font-size: 16px;
      font-style: normal; font-variant: normal; font-weight: 400;
      letter-spacing: normal; orphans: 2; text-align: left;
      text-decoration: none; text-indent: 0px; text-transform: none;
      -webkit-text-stroke-width: 0px; white-space: normal; word-spacing:
      0px;">Первый из параметров - "агрессивность" - задаёт в процентах,
      насколько сильной должна быть коррекция.&nbsp; Уменьшение значения
      этого параметра может избавить от излишней коррекции для
      монтировок с небольшим люфтом или без люфта. Если включен параметр
      "быстрое переключение для больших отклонений", PHD2 мгновенно
      отреагирует на большую величину отклонения при смене направления,
      а не будет ждать&nbsp; трёх последовательных отклонений в новом
      направлении, как при нормальном поведении.&nbsp; Это помогает
      быстрее откорректировать большие отклонения, вызванные ветром,
      зацепившимся проводом или другими механическими причинами.&nbsp;
      "Большими отклонениями" считаются те, которые трёхкратно превышают
      минимальное перемещение.&nbsp; Поэтому если PHD2 избыточно
      реагирует на изменения направления, это можно подправить
      настройкой минимального перемещения или отключить "быстрое
      переключение".&nbsp; Помните, что в отношении гидирования по
      склонению справедливо ленинское "лучше меньше, да лучше" и не
      злоупотребляйте излишней настройкой.</span><br>
    <br>
    Алгоритм <a name="LowPass"></a><span style="font-weight: bold;">сглаживания





    </span>также использует для вычисления текущей поправки
    предыдущие.&nbsp; Отправной точкой является усреднённое отклонение
    звезды, на основе предыдущих данных. Это означает, что отклонение
    звезды на текущем кадре играет весьма небольшую роль и алгоритм
    очень устойчив к быстрым изменениям. По истории поправок можно также
    определить, действуют ли ли отклонения в нужном направлении, или
    становятся "всё хуже". <span style="display: inline !important;
      float: none; background-color: transparent; color: rgb(0, 0, 0);
      font-family: Times New Roman; font-size: 16px; font-style: normal;
      font-variant: normal; font-weight: 400; letter-spacing: normal;
      orphans: 2; text-align: left; text-decoration: none; text-indent:
      0px; text-transform: none; -webkit-text-stroke-width: 0px;
      white-space: normal; word-spacing: 0px;">Параметр </span><span
      style="background-color: transparent; color: rgb(0, 0, 0);
      font-family: Times New Roman; font-size: 16px; font-style: normal;
      font-variant: normal; font-weight: 700; letter-spacing: normal;
      orphans: 2; text-align: left; text-decoration: none; text-indent:
      0px; text-transform: none; -webkit-text-stroke-width: 0px;
      white-space: normal; word-spacing: 0px;"><a name="slope_weight_"></a>коэффициент


      наклона</span><span style="display: inline !important; float:
      none; background-color: transparent; color: rgb(0, 0, 0);
      font-family: Times New Roman; font-size: 16px; font-style: normal;
      font-variant: normal; font-weight: 400; letter-spacing: normal;
      orphans: 2; text-align: left; text-decoration: none; text-indent:
      0px; text-transform: none; -webkit-text-stroke-width: 0px;
      white-space: normal; word-spacing: 0px;">, выраженный в процентах,
      определяет степень влияния в подсчётах гидирующих движений.&nbsp;
      Если он установлен в ноль, величина импульса всегда будет средней
      относительно недавней истории.&nbsp; Если нет -&nbsp; среднее
      значение будет изменено в сторону увеличения или уменьшения в
      зависимости от текущего наклона направляющей движения опорной
      звезды. </span>Поскольку алгоритм очень устойчив к быстрым
    изменениям, он наиболее применим для гидирования по склонению.<br>
    <br>
    Алгоритм <span style="font-weight: bold;"><a name="LowPass2"></a>сглаживания2</span>
    - это разновидность предыдущего с несколько отличающимся
    поведением.&nbsp; Он также поддерживает историю гидирования, но
    последующая поправка является линейным продолжением предыдущей (т.е.
    расчётом наклона).&nbsp; Это продолжается до тех пор, пока
    необходимость изменения направления не станет слишком явной, после
    чего история будет очищена.&nbsp; Алгоритм имеет два настраиваемых
    параметра: минимальное движение и агресссивность. Минимальное
    движение имеет тот же смысл, что и для других алгоритмов, а
    агрессивность (в процентах) - коэффициент затухания дальнейших
    поправок.&nbsp; Сглаживание2 - очень консервативный и тормозной
    алгоритм, который может быть хорошим выбором для пользователей с
    хорошими атмосферными условиями и качественными монтировками, где
    люфт по склонению мал или отсутствует.<br>
    <br>
    Алгоритм <span style="font-weight: bold;"><a name="Predictive_PEC"></a>прогноза
      периодической ошибки (PPEC)</span>
    <p class="MsoNormal"><o:p>&nbsp;</o:p><b style="">Overview<o:p></o:p></b></p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p>Алгоритм PPEC отличается от
      прочих своими моделирующими и прогностическими возможностями.<span
        style="">&nbsp; </span>Он анализирует ведение монтировки и
      вычисляет поправки до того, как периодическая ошибка себя проявит.<span
        style="">&nbsp; </span>Упреждающие поправки уменьшают задержку
      реагирования, присущую традиционному гидированию и значительно
      улучшают производительность.<span style="">&nbsp; </span>Остальные
      алгоритмы исправляют уже возникшую ошибку.<span style="">&nbsp;&nbsp;

      </span></p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p>Алгоритм анализирует
      повторяющиеся, а, следовательно, и прогнозируемые ошибки.<span
        style="">&nbsp; Он использует сложную модель гауссовского
        процесса, разработанную иссдедовательской группой института
        Макса Планка в Германии</span>.<span style="">&nbsp; </span>Математические
      подробности можно посмотреть здесь:</p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p><a
        href="http://ieeexplore.ieee.org/document/7105398/?reload=true">http://ieeexplore.ieee.org/document/7105398/?reload=true</a></p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p>Алгоритм PPEC обычно
      используется для прямого восхождения, где остаточная ошибка
      периодики и другие ошибки передачи уменьшают точность ведения.<span
        style="">&nbsp; Алгоритм использует отдельные шкалы времени,
        описывающие поведение системы</span>: </p>
    <p class="MsoListBullet"><o:p>&nbsp;</o:p><span style="font-family:
        Symbol;"><span style="">·<span style="font-family: &quot;Times
            New Roman&quot;; font-style: normal; font-variant: normal;
            font-weight: normal; font-size: 7pt; line-height: normal;
            font-size-adjust: none; font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </span></span></span>Краткосрочную: для высокочастотных
      ошибок, таких как вызванные шероховатостью передачи или
      турбулентностью<br>
      <span style="font-family: Symbol;"><span style="">·<span
            style="font-family: &quot;Times New Roman&quot;; font-style:
            normal; font-variant: normal; font-weight: normal;
            font-size: 7pt; line-height: normal; font-size-adjust: none;
            font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </span></span></span>Среднесрочную:&nbsp; <span style=""></span>для
      остаточных периодических ошибок, обычно наблюдаемых в промежутках
      не более периода обращения червяка<br>
      <span style="font-family: Symbol;"><span style="">·<span
            style="font-family: &quot;Times New Roman&quot;; font-style:
            normal; font-variant: normal; font-weight: normal;
            font-size: 7pt; line-height: normal; font-size-adjust: none;
            font-stretch: normal;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
          </span></span></span>Долгосрочную: <span id="result_box"
        class="" lang="ru"><span class="">для устойчивого дрейфа и для
          более низкочастотных (более длительных) гармоник, которые
          могут быть вызваны взаимодействием нескольких передач в
          приводе</span></span></p>
    <p class="MsoNormal"><o:p>&nbsp;Краткосрочные помехи являются
        непоедсказуемыми; они</o:p> отфильтровываются, чтобы
      идентифицировать предсказуемые компоненты.<span style="">&nbsp;
        Для большинства монтировок наиболее важным является
        среднесрочный компонент</span>.<span style="">&nbsp; </span>If
      you’re following best practices, you will have programmed periodic
      error correction in your mount (assuming that feature is available
      to you).<span style="">&nbsp; </span>Doing
      this reduces the amount of work that needs to be done by PHD2, and
      the PEC correction in the mount is normally saved permanently.<span
        style="">&nbsp; </span>This approach is preferable to having to
      measure and infer the periodic error behavior every time you set
      up your equipment.<span style="">&nbsp; </span>That said, PEC in
      the mount is never perfect, and you will often see residual
      repetitive errors even when PEC is active.<span style="">&nbsp; </span>These
      often arise when the tracking errors occur with a frequency that
      is not a harmonic (integer fraction) of the mount’s worm period –
      most PEC implementations can’t deal with those.<span style="">&nbsp;
      </span>You can also get residual periodic errors if they are
      dependent on the mechanical loading of the mount or if the mount’s
      behavior has changed since the PEC was programmed.<span style="">&nbsp;
      </span>The PPEC algorithm can be quite effective at identifying
      and reducing these errors because it doesn’t depend on the worm
      period and is always doing a fresh analysis of the mount’s current
      behavior.</p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p>The PPEC algorithm will also
      detect and proactively correct for drift errors.<span style="">&nbsp;
      </span>Although drift is typically handled well by any of the
      guide algorithms, the corrections will always lag the error by
      some amount.<span style="">&nbsp; </span>For
      some use cases – perhaps spectroscopy, photometry or
      comet-tracking – this might be a problem, in which case PPEC may
      deliver better results.<span style="">&nbsp; </span></p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p>Since PPEC employs a learning
      process, it will usually take about 2 worm periods to model the
      mount and become fully effective.<span style="">&nbsp; </span>During
      this training period, the algorithm will behave more like the
      ‘hysteresis’ algorithm, so you won’t normally see a performance
      penalty while the internal model is being built.<span style="">&nbsp;
      </span>Instead, you’re likely to see a steady improvement in
      tracking as the model is refined and the algorithm shifts
      seamlessly from hysteresis to predictive-mode.<span style="">
        &nbsp; This improvement can usually be seen even before the
        medium-term mount behavior is fully modeled. </span></p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p>Since the PPEC model is
      implicitly tied to the state of the gear train, it must be
      re-learned if the mount is slewed to a new target.<span style="">&nbsp;
      </span>For the same reason, it can’t be retained across different
      guiding sessions, which is why conventional PEC is important.<span
        style="">&nbsp; </span>However, the PPEC model will remain
      intact during dither operations and while guiding is paused (via
      automation) for activities like focusing.<span style="">&nbsp; </span>For
      the most common use-case, namely imaging the same target for
      multiple hours with periodic dithering, the PPEC model will remain
      valid.<span style="">&nbsp; </span>In any case, the learning
      process and transition from one mode to the other is handled
      automatically, so you won’t need to pay it any attention.</p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p><b style="">Algorithm Details<o:p></o:p></b></p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p>Once the training period is
      completed, the PPEC algorithm computes the guide correction using
      two factors.<span style="">&nbsp; </span>One is reactive, based
      on the displacement of the guide star in the most recent exposure.<span
        style="">&nbsp; </span>The second is predictive, based on the
      output from the Gaussian process model constructed during the
      training period.<span style="">&nbsp; </span>Each of these terms
      includes a separate gain or aggressiveness factor, so the final
      guide pulse amount is a sum: </p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p>&nbsp;&nbsp;&nbsp;
      Guide-correction = (predicted amount * predictive gain) + (recent
      displacement * reactive gain)</p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p>The ‘<b style="">predictive</b>
      <b style="">gain’</b> and ‘<b style="">reactive</b> <b style="">gain’</b>
      parameters are exposed in the Advanced Dialog, and their default
      values for these parameters should work well for most mounts.<span
        style="">&nbsp; </span>You should be conservative about
      changing them because bad choices for these parameters can
      definitely make your guiding worse.</p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p>During the training period,
      the algorithm needs to identify periodic errors in the observed
      guide star movement.<span style="">&nbsp; </span>For initial
      trials, you can use the worm period of your mount as the starting
      point for the ‘<b style="">period</b> <b style="">length’</b>.<span
        style="">&nbsp; </span>This gives the algorithm a good starting
      point, but you should also leave the ‘auto-adjust period’ option
      checked.<span style="">&nbsp; </span>This tells the algorithm to
      adjust the period as needed to better control whatever periodic
      errors it finds. &nbsp;Once you have run the altorithm multiple
      times and are happy with the results, you can leave this field set
      to whatever value was computed in the previous sessions.</p>
    <p class="MsoNormal"><o:p>&nbsp;</o:p>The ‘<b style="">min-move’</b>
      parameter affects only the reactive component of the algorithm.<span
        style="">&nbsp; </span>If the measured star displacement is
      less than this amount, the reactive component will be set to zero.<span
        style="">&nbsp; </span>However, the predictive component of the
      algorithm will still be computed and applied.</p>
    <br>
    <br>
    <br>
    &nbsp;&nbsp;
  </body>
</html>
